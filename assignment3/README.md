# Assignment3 - Basic Ray Tracer

## Introduction

In this assignment, you are required to implement a basic ray tracing algorithm with Phong lighting model.

You need to render an image and save the result. Image I/O is achieved by *stb_image*, a header only, light-weighted library for image io. We use *Eigen* as the math lib. We will provide a brief introduction to *Eigen* in the tutorial.

You can click the [link](https://classroom.github.com/a/AlpKYYEj) to accept the homework from Github classroom.

In the following, we will give you the specifics about what you need to accomplish, as well as some related guidelines to assist your programming. When you have finished all your work, you will need to complete an assignment report (in report directory) to show how you completed the assignment, which needs to be written using LATEX.

## Programming Requirements

### Must

- generate rays from camera (10 pts)
- ray geometry intersection (30 pts)
- Phong lighting at intersection (15 pts)
- light ray sampling for soft shadow (25 pts)
- anti-aliasing by super-resolution (10 pts)

### Bonus

- texture mapping (10 pts)
- normal/displacement texture (15 pts)
- texture filtering using mip-map/EWA (10/20 pts)
- advanced anti-aliasing (10 pts)
- fast B-spline/NURBS surface intersection test (30 pts)

## Demonstration Requirements

In addition to programming, you will also need to demonstrate your code to TAs.

Things you should prepare:

- Explain how you set up the camera and generate rays for each pixel.
- Explain how you do intersection test for different geometries.
- Explain how you implement direct lighting with Phong model.
- Explain how you implement visibility test and sample the light to generate soft shadows.
- Explain how you implement super-resolution for anti-aliasing.
- For the optional part(s), explain your implementations and show it(them)!

Additional Notification:

- You should try your best to present your ideas as clearly as possible.
- If you do not follow the above requirements, your score will be deduced by 10% of the entire assignment score.

## Submission

You are required to push following items to Github repository:

- Your source codes.
- All images you rendered.
- A PDF-formatted report. You should use the LaTeX template we provided.

Submission deadline: **November 15, 2022, 22:00 UTC+8**

## Grading Rules

- You will get additional scores if you choose to do bonus items. Please prepare convincing results to prove that your implementations of bonus items are correct. The maximum additional score is 30 points.
- NO CHEATING! You should work independently. Please node that images you submitted or shown to TAs when offline check should be generated by the code you pushed on Github. We will run your code on Github to verify that.
- Late submission will be subject to score deduction rules on the course website.

## Skeleton Project/Report Template

By default, you will get a black image with resolution of 400 x 400. We will test your program by an auto scripts on Github. **Please make sure that in your final version of submitted codes, default setting of the scene and camera is not changed.**

The skeleton program and report template will be provided once you accept the assignment link of GitHub classroom which we published in Piazza. If you accept the assignment through link properly, a repository which contains the skeleton project and report template will be created under your GitHub account. Please follow the template to prepare your report.

You should complete your assignment submission to your repository through GitHub before the deadline.

## Implementation Guide

### Basic ray tracing with direct lighting

First, you need to implement a pin-hole camera model that can generate rays according to the coordinates you calculated in screen space based on the camera location and view direction.

Then, you need to implement the algorithm testing ray-geometry intersection.

- Triangle: a triangle is defined by giving the coordinates of its three vertices. The vertices are given in anti-clockwise order. (i.e. given v0, v1, v2, the normal direction of the triangle is $(v_1 - v_0)\times (v_2- v_1)$.
- Ellipsoid: an ellipsoid is defined by giving the position, and $\vec{a}$, $\vec{b}$, and $\vec{c}$. You can learn more about ray-ellipsoid intersection test [here](http://www.illusioncatalyst.com/notes_files/mathematics/line_nu_sphere_intersection.php).
- Rectangle: a rectangle is defined by giving the position, normal direction, size and tangent direction.

![Ellipsoid](https://faculty.sist.shanghaitech.edu.cn/faculty/liuxp/course/cs171.01/assignment/assignment3/line_nu_sphere_intersection.png) ![Rectangle](https://faculty.sist.shanghaitech.edu.cn/faculty/liuxp/course/cs171.01/assignment/assignment3/rectangle.png)

For each interaction point, you need to apply Phong lighting model to compute radiance.

To produce soft shadow, You need to sample the light and do visibility test with shadow rays at the interaction point.

At last, you need to implement anti-aliasing by super-resolution the rays for each pixel.

Your result should be like this after you finish basic part of this assignment.

![result](https://faculty.sist.shanghaitech.edu.cn/faculty/liuxp/course/cs171.01/assignment/assignment3/temp_res.png)

### More on texture and anti-aliasing

You need to load texture(s) from image on hard disk and apply the texture to the surface of the objects. You can also add support for normal texture or displacement texture. We have provided a wood texture for you. You can also make your own texture. You can apply texture to any object in the scene, or add extra objects. You can download more textures [here](https://polyhaven.com/textures).

You can implement texture filtering to void aliasing. You will get at most 20 bonus points for texture filtering part. Here we introduce a more advanced algorithm called EWA, you can learn more about it here in [pbrt book](https://www.pbr-book.org/3ed-2018/Texture/Image_Texture#EllipticallyWeightedAverage). You can use the grid texture we provided to demonstrate the effectiveness of your implementation.

Here is a demo of mipmap, applying a grid texture on an infinite plane. (left: with mipmap, right: without mipmap).

![mipmap](https://faculty.sist.shanghaitech.edu.cn/faculty/liuxp/course/cs171.01/assignment/assignment3/mipmap.png)

For anti-aliasing, you can try some more advanced anti-aliasing techniques, for example, rotated grid or jittered sampling. You can also try low discrepancy sequence like [Halton-sequence](https://en.wikipedia.org/wiki/Halton_sequence) to produce better random samples.

**Note: For anti-aliasing, you still need to implement basic super-resolution algorithm first. You can compare the result of super-resolution with other advanced algorithm in your report.**

### Challenge Open Problems

Open problem: fast intersection test between ray and B-spline/NURBS surface. You may try to find a fast algorithm to test intersection between B-spline/NURBS surface and ray.